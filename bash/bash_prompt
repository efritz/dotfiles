#!/usr/bin/env bash

#
# Define common colors (see http://git.io/solarized-colors)

if tput setaf 1 &> /dev/null; then
    tput sgr0;
    bold=$(tput bold);
    reset=$(tput sgr0);
    blue=$(tput setaf 33);
    cyan=$(tput setaf 37);
    red=$(tput setaf 124);
    violet=$(tput setaf 61);
    white=$(tput setaf 15);
    yellow=$(tput setaf 136);
else
    bold='';
	reset="\e[0m";
	blue="\e[1;34m";
	cyan="\e[1;36m";
	red="\e[1;31m";
	violet="\e[1;35m";
	white="\e[1;37m";
    yellow="\e[1;33m";
fi

user_style() {
    # Highlight the user name when logged in as root.
    if [[ "${USER}" == "root" ]]; then echo "${bold}${red}"; else echo "${blue}"; fi;
}

host_style() {
    # Highlight the host name when connected via SSH.
    if [[ "${SSH_TTY}" ]]; then echo "${bold}${red}"; else echo "${cyan}"; fi;
}

current_git_branch() {
    # Check if the current directory is in a Git repository.
    git rev-parse --is-inside-work-tree &>/dev/null || return;

    # Get a short symbolic ref, the short SHA for the latest commit, or just the string (unknown)
    echo "$(git symbolic-ref --quiet --short HEAD 2> /dev/null || git rev-parse --short HEAD 2> /dev/null || echo '(unknown)')";
}

current_git_status() {
    # Check if the current directory is in a Git repository.
    git rev-parse --is-inside-work-tree &>/dev/null || return;

    # Skip if we're inside the .git directory
    "$(git rev-parse --is-inside-git-dir 2> /dev/null)" != 'true' && return

    # Ensure the index is up to date.
    git update-index --really-refresh -q &>/dev/null;

    #
    # Print state of current directory

    local s=''
    if ! $(git diff --quiet --ignore-submodules --cached);   then s+='+'; fi; # Uncommitted changes
    if ! $(git diff-files --quiet --ignore-submodules --);   then s+='!'; fi; # Unstaged changes
    if [ -n "$(git ls-files --others --exclude-standard)" ]; then s+='?'; fi; # Untracked files
    if $(git rev-parse --verify refs/stash &>/dev/null);     then s+='$'; fi; # Stashed files

    echo $s
}

prompt_git_branch() {
    local s="$(current_git_branch)"

    if [ -n "${s}" ]; then
        echo " on ${s}";
    fi;
}

prompt_git_status() {
    local s="$(current_git_status)"

    if [ -n "${s}" ]; then
        echo " [${s}]";
    fi;
}

PS1=""
PS1+="\[$(user_style)\]\u"
PS1+="\[${reset}\]@"
PS1+="\[$(host_style)\]\h"
PS1+="\[${reset}\]:"
PS1+="\w/"
PS1+="\[${violet}\]\$(prompt_git_branch)\[${red}\]\$(prompt_git_status)"
PS1+="\[${white}\] \$ "
PS1+="\[${reset}\]"
export PS1;

PS2="\[${yellow}\]> \[${reset}\]";
export PS2;

export -f prompt_git_branch
export -f prompt_git_status
